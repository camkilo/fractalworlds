"""
Fractal Fantasy World - Main Game Engine
=========================================
Epic, immersive fantasy world where nature, creatures, and structures 
are generated by fractals, logic, and math patterns.
"""

import numpy as np
import json
from typing import Dict, List, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum


class BiomeType(Enum):
    """Biome types for the fantasy world"""
    FOREST = "forest"
    MOUNTAINS = "mountains"
    PLAINS = "plains"
    DESERT = "desert"
    SWAMP = "swamp"
    TUNDRA = "tundra"
    MAGICAL_GROVE = "magical_grove"


@dataclass
class WorldConfig:
    """Configuration for world generation"""
    seed: int = 42
    world_size: int = 512
    fractal_iterations: int = 8
    terrain_roughness: float = 0.6
    water_level: float = 0.3
    tree_density: float = 0.4
    creature_density: float = 0.1
    magic_intensity: float = 0.7
    lighting_quality: str = "cinematic"
    enable_animations: bool = True


class FractalWorld:
    """Main class for the fractal-based fantasy world"""
    
    def __init__(self, config: WorldConfig = None):
        self.config = config or WorldConfig()
        np.random.seed(self.config.seed)
        self.terrain = None
        self.biomes = None
        self.forests = []
        self.rivers = []
        self.villages = []
        self.caves = []
        self.creatures = []
        self.structures = []
        self.lighting = None
        self.sky = None
        self.weather = None
        
    def generate_world(self) -> Dict[str, Any]:
        """Generate the complete fantasy world"""
        print("ğŸŒ Generating Fractal Fantasy World...")
        
        # Generate terrain using fractal algorithms
        self.terrain = self._generate_terrain()
        print("  âœ“ Terrain generated with fractal patterns")
        
        # Generate biomes based on terrain
        self.biomes = self._generate_biomes()
        print("  âœ“ Biomes generated using mathematical rules")
        
        # Generate procedural forests
        self.forests = self._generate_forests()
        print(f"  âœ“ {len(self.forests)} procedural forests generated")
        
        # Generate rivers with flow algorithms
        self.rivers = self._generate_rivers()
        print(f"  âœ“ {len(self.rivers)} algorithmic rivers generated")
        
        # Generate villages and settlements
        self.villages = self._generate_villages()
        print(f"  âœ“ {len(self.villages)} villages generated")
        
        # Generate caves and underground systems
        self.caves = self._generate_caves()
        print(f"  âœ“ {len(self.caves)} cave systems generated")
        
        # Generate creatures with geometric patterns
        self.creatures = self._generate_creatures()
        print(f"  âœ“ {len(self.creatures)} geometric creatures spawned")
        
        # Generate fractal structures
        self.structures = self._generate_structures()
        print(f"  âœ“ {len(self.structures)} fractal structures created")
        
        # Setup lighting system
        self.lighting = self._setup_lighting()
        print("  âœ“ Cinematic lighting configured")
        
        # Generate dynamic sky
        self.sky = self._generate_sky()
        print("  âœ“ Dynamic sky system initialized")
        
        # Generate weather system
        self.weather = self._generate_weather_system()
        print("  âœ“ Dynamic weather system initialized")
        
        print("âœ¨ World generation complete!")
        
        return self.get_world_data()
    
    def _generate_terrain(self) -> np.ndarray:
        """Generate terrain using multi-octave fractal noise"""
        size = self.config.world_size
        terrain = np.zeros((size, size))
        
        # Generate multiple octaves of noise for fractal terrain
        octaves = min(self.config.fractal_iterations, 8)
        roughness = self.config.terrain_roughness
        
        for octave in range(octaves):
            freq = 2 ** octave
            amp = roughness ** octave
            
            for y in range(size):
                for x in range(size):
                    # Generate fractal noise using sine/cosine combinations
                    nx = x / size * freq
                    ny = y / size * freq
                    
                    # Combine multiple noise sources
                    noise = (np.sin(nx * 3.14159 + np.random.random() * 0.1) * 
                            np.cos(ny * 3.14159 + np.random.random() * 0.1))
                    noise += (np.sin(nx * 1.5 + 2.5) * np.cos(ny * 1.5 + 3.7)) * 0.5
                    
                    terrain[y, x] += noise * amp
        
        # Apply additional fractal detail using diamond-square-like perturbations
        for _ in range(3):
            for y in range(1, size - 1):
                for x in range(1, size - 1):
                    # Average neighbors with some randomness
                    avg = (terrain[y-1, x] + terrain[y+1, x] + 
                          terrain[y, x-1] + terrain[y, x+1]) / 4
                    terrain[y, x] = terrain[y, x] * 0.7 + avg * 0.3 + \
                                   np.random.uniform(-roughness, roughness) * 0.1
        
        # Normalize terrain to [0, 1]
        terrain = (terrain - terrain.min()) / (terrain.max() - terrain.min())
        return terrain
    
    def _generate_biomes(self) -> np.ndarray:
        """Generate biomes based on terrain height and moisture"""
        size = self.config.world_size
        biomes = np.zeros((size, size), dtype=object)
        
        # Generate moisture map using Perlin-like noise
        moisture = self._generate_noise_map(size, scale=50)
        
        for y in range(size):
            for x in range(size):
                height = self.terrain[y, x]
                m = moisture[y, x]
                
                # Determine biome based on height and moisture
                if height < self.config.water_level:
                    biomes[y, x] = "water"
                elif height > 0.8:
                    biomes[y, x] = BiomeType.MOUNTAINS.value
                elif height > 0.6 and m < 0.3:
                    biomes[y, x] = BiomeType.DESERT.value
                elif m > 0.7:
                    if np.random.random() < self.config.magic_intensity * 0.2:
                        biomes[y, x] = BiomeType.MAGICAL_GROVE.value
                    else:
                        biomes[y, x] = BiomeType.FOREST.value
                elif m > 0.5:
                    biomes[y, x] = BiomeType.SWAMP.value if height < 0.4 else BiomeType.FOREST.value
                elif height < 0.35 and m < 0.4:
                    biomes[y, x] = BiomeType.TUNDRA.value
                else:
                    biomes[y, x] = BiomeType.PLAINS.value
        
        return biomes
    
    def _generate_noise_map(self, size: int, scale: float) -> np.ndarray:
        """Generate Perlin-like noise map"""
        noise = np.zeros((size, size))
        
        for octave in range(4):
            freq = 2 ** octave / scale
            amp = 0.5 ** octave
            
            for y in range(size):
                for x in range(size):
                    noise[y, x] += np.sin(x * freq + np.random.random()) * \
                                   np.cos(y * freq + np.random.random()) * amp
        
        noise = (noise - noise.min()) / (noise.max() - noise.min())
        return noise
    
    def _generate_forests(self) -> List[Dict[str, Any]]:
        """Generate procedural forests using L-systems"""
        forests = []
        
        for y in range(0, self.config.world_size, 20):
            for x in range(0, self.config.world_size, 20):
                if self.biomes[y, x] in [BiomeType.FOREST.value, BiomeType.MAGICAL_GROVE.value]:
                    if np.random.random() < self.config.tree_density:
                        forest = self._create_forest_patch(x, y)
                        forests.append(forest)
        
        return forests
    
    def _create_forest_patch(self, x: int, y: int) -> Dict[str, Any]:
        """Create a forest patch using L-system tree generation"""
        is_magical = self.biomes[y, x] == BiomeType.MAGICAL_GROVE.value
        
        # L-system parameters for tree generation
        axiom = "F"
        rules = {"F": "FF+[+F-F-F]-[-F+F+F]"}
        iterations = 4
        angle = 25
        
        # Generate L-system string
        current = axiom
        for _ in range(iterations):
            next_str = ""
            for char in current:
                next_str += rules.get(char, char)
            current = next_str
        
        trees = []
        num_trees = np.random.randint(5, 15)
        
        for _ in range(num_trees):
            tree_x = x + np.random.randint(-10, 10)
            tree_y = y + np.random.randint(-10, 10)
            height = np.random.uniform(3, 8) if not is_magical else np.random.uniform(5, 12)
            
            tree = {
                "position": (tree_x, tree_y, self.terrain[min(y, self.config.world_size-1), 
                                                         min(x, self.config.world_size-1)] * 50),
                "l_system": current[:50],  # Truncate for storage
                "height": height,
                "angle": angle,
                "is_magical": is_magical,
                "glow_intensity": np.random.uniform(0.5, 1.0) if is_magical else 0,
                "foliage_density": np.random.uniform(0.6, 1.0)
            }
            trees.append(tree)
        
        return {
            "center": (x, y),
            "trees": trees,
            "biome": self.biomes[y, x]
        }
    
    def _generate_rivers(self) -> List[Dict[str, Any]]:
        """Generate rivers using flow algorithms"""
        rivers = []
        num_rivers = max(3, self.config.world_size // 100)
        
        for _ in range(num_rivers):
            # Start from high elevation
            start_points = np.where(self.terrain > 0.7)
            if len(start_points[0]) == 0:
                continue
                
            idx = np.random.randint(len(start_points[0]))
            start_y, start_x = start_points[0][idx], start_points[1][idx]
            
            # Flow downhill using gradient descent
            path = [(start_x, start_y, self.terrain[start_y, start_x])]
            current_x, current_y = start_x, start_y
            
            for _ in range(200):
                # Find lowest neighbor
                lowest_h = self.terrain[current_y, current_x]
                next_x, next_y = current_x, current_y
                
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        ny, nx = current_y + dy, current_x + dx
                        if 0 <= ny < self.config.world_size and 0 <= nx < self.config.world_size:
                            if self.terrain[ny, nx] < lowest_h:
                                lowest_h = self.terrain[ny, nx]
                                next_x, next_y = nx, ny
                
                if (next_x, next_y) == (current_x, current_y):
                    break  # Reached local minimum
                
                current_x, current_y = next_x, next_y
                path.append((current_x, current_y, self.terrain[current_y, current_x]))
                
                if self.terrain[current_y, current_x] < self.config.water_level:
                    break  # Reached water
            
            if len(path) > 10:
                rivers.append({
                    "path": path,
                    "width": np.random.uniform(2, 8),
                    "flow_speed": np.random.uniform(0.5, 2.0),
                    "has_magic": np.random.random() < self.config.magic_intensity * 0.3,
                    "glow_color": (
                        np.random.randint(100, 255),
                        np.random.randint(150, 255),
                        np.random.randint(200, 255)
                    ) if np.random.random() < 0.3 else None
                })
        
        return rivers
    
    def _generate_creatures(self) -> List[Dict[str, Any]]:
        """Generate creatures with geometric patterns and realistic features"""
        creatures = []
        num_creatures = int(self.config.world_size * self.config.world_size * self.config.creature_density / 1000)
        
        creature_types = [
            {"name": "Fractal Dragon", "pattern": "mandelbrot", "size": "large", "magic": 0.9, "is_humanoid": False},
            {"name": "Geometric Wolf", "pattern": "hexagonal", "size": "medium", "magic": 0.3, "is_humanoid": False},
            {"name": "Spiral Serpent", "pattern": "fibonacci", "size": "medium", "magic": 0.6, "is_humanoid": False},
            {"name": "Crystal Spider", "pattern": "octahedral", "size": "small", "magic": 0.4, "is_humanoid": False},
            {"name": "Pattern Bird", "pattern": "recursive", "size": "small", "magic": 0.5, "is_humanoid": False},
            {"name": "Golden Bear", "pattern": "golden_ratio", "size": "large", "magic": 0.2, "is_humanoid": False},
            {"name": "Ancient Guardian", "pattern": "geometric", "size": "large", "magic": 0.7, "is_humanoid": True},
            {"name": "Forest Sprite", "pattern": "nature", "size": "small", "magic": 0.8, "is_humanoid": True},
        ]
        
        for _ in range(num_creatures):
            x = np.random.randint(0, self.config.world_size)
            y = np.random.randint(0, self.config.world_size)
            
            # Skip water areas
            if self.terrain[y, x] < self.config.water_level:
                continue
            
            creature_type = creature_types[np.random.randint(len(creature_types))]
            
            creature = {
                "type": creature_type["name"],
                "position": (x, y, self.terrain[y, x] * 50),
                "pattern": creature_type["pattern"],
                "size": creature_type["size"],
                "is_humanoid": creature_type["is_humanoid"],
                "geometric_complexity": np.random.randint(4, 12),
                "color_palette": self._generate_geometric_colors(creature_type["pattern"]),
                "magic_level": creature_type["magic"] * self.config.magic_intensity,
                "glow_intensity": creature_type["magic"] * np.random.uniform(0.5, 1.0),
                "animation_speed": np.random.uniform(0.5, 1.5),
                "movement_pattern": self._generate_movement_pattern(),
                "biome": self.biomes[y, x],
                # Enhanced visual features
                "textures": self._generate_creature_textures(creature_type),
                "animations": self._generate_creature_animations(creature_type),
                "equipment": self._generate_creature_equipment(creature_type) if creature_type["is_humanoid"] else None,
                "magical_effects": self._generate_creature_magic_effects(creature_type["magic"]),
                # Procedural variations
                "variant_seed": np.random.randint(0, 10000),
                "scale_variation": np.random.uniform(0.85, 1.15),
                "color_tint": (np.random.randint(-20, 20), np.random.randint(-20, 20), np.random.randint(-20, 20))
            }
            creatures.append(creature)
        
        return creatures
    
    def _generate_geometric_colors(self, pattern: str) -> List[Tuple[int, int, int]]:
        """Generate color palette based on geometric pattern"""
        palettes = {
            "mandelbrot": [(75, 0, 130), (138, 43, 226), (186, 85, 211)],
            "hexagonal": [(255, 215, 0), (255, 165, 0), (255, 140, 0)],
            "fibonacci": [(34, 139, 34), (50, 205, 50), (144, 238, 144)],
            "octahedral": [(135, 206, 235), (176, 224, 230), (240, 248, 255)],
            "recursive": [(220, 20, 60), (255, 99, 71), (255, 160, 122)],
            "golden_ratio": [(184, 134, 11), (218, 165, 32), (238, 232, 170)],
            "geometric": [(128, 128, 128), (160, 160, 160), (192, 192, 192)],
            "nature": [(34, 139, 34), (0, 255, 127), (144, 238, 144)]
        }
        return palettes.get(pattern, [(128, 128, 128)])
    
    def _generate_creature_textures(self, creature_type: Dict[str, Any]) -> Dict[str, Any]:
        """Generate detailed textures for creatures"""
        return {
            "base_texture": {
                "type": "procedural",
                "pattern": creature_type["pattern"],
                "resolution": 2048 if creature_type["size"] == "large" else 1024,
                "detail_level": np.random.uniform(0.7, 1.0)
            },
            "normal_map": {
                "enabled": True,
                "strength": np.random.uniform(0.5, 1.0),
                "detail": "high"
            },
            "roughness": np.random.uniform(0.2, 0.8),
            "metallic": np.random.uniform(0.0, 0.3) if creature_type["pattern"] in ["octahedral", "geometric"] else 0.0,
            "subsurface_scattering": {
                "enabled": True if creature_type["is_humanoid"] else False,
                "radius": 0.5,
                "color": (255, 200, 180)
            },
            "iridescence": np.random.uniform(0.0, 0.5) if creature_type["pattern"] in ["mandelbrot", "recursive"] else 0.0
        }
    
    def _generate_creature_animations(self, creature_type: Dict[str, Any]) -> Dict[str, Any]:
        """Generate realistic animations for creatures"""
        base_animations = {
            "idle": {
                "breathing": {
                    "enabled": True,
                    "rate": np.random.uniform(0.3, 0.7),
                    "amplitude": np.random.uniform(0.02, 0.08)
                },
                "fidget": {
                    "enabled": True,
                    "frequency": np.random.uniform(0.1, 0.3),
                    "variations": ["look_around", "stretch", "shake"]
                }
            },
            "movement": {
                "walk": {
                    "speed": 1.0,
                    "stride_length": 1.2 if creature_type["size"] == "large" else 0.8,
                    "bob_amplitude": 0.1
                },
                "run": {
                    "speed": 2.5,
                    "stride_length": 1.8 if creature_type["size"] == "large" else 1.2,
                    "bob_amplitude": 0.15
                }
            },
            "combat": {
                "attack": {
                    "windup_time": 0.3,
                    "strike_time": 0.2,
                    "recovery_time": 0.4
                },
                "defend": {
                    "reaction_time": 0.15
                },
                "hurt": {
                    "flinch_duration": 0.3,
                    "knockback": np.random.uniform(0.5, 1.5)
                }
            }
        }
        
        # Add humanoid-specific animations
        if creature_type["is_humanoid"]:
            base_animations["facial_expressions"] = {
                "enabled": True,
                "expressions": ["neutral", "alert", "aggressive", "friendly", "surprised"],
                "blend_time": 0.2,
                "eye_blink_rate": 0.2
            }
            base_animations["gestures"] = {
                "enabled": True,
                "types": ["point", "wave", "gesture", "cast_spell"]
            }
        
        return base_animations
    
    def _generate_creature_equipment(self, creature_type: Dict[str, Any]) -> Dict[str, Any]:
        """Generate equipment for humanoid creatures"""
        if not creature_type["is_humanoid"]:
            return None
        
        equipment_styles = ["tribal", "mystical", "ancient", "nature-bound"]
        style = equipment_styles[np.random.randint(len(equipment_styles))]
        
        return {
            "armor": {
                "type": style,
                "coverage": np.random.uniform(0.3, 0.8),
                "material": "organic" if style == "nature-bound" else "crafted",
                "color": tuple(np.random.randint(100, 200, 3)),
                "glow": creature_type["magic"] > 0.5
            },
            "weapon": {
                "type": "staff" if creature_type["magic"] > 0.5 else np.random.choice(["sword", "spear", "bow"]),
                "magical": creature_type["magic"] > 0.5,
                "elemental_effect": np.random.choice(["fire", "ice", "nature", "arcane"]) if creature_type["magic"] > 0.5 else None
            },
            "accessories": {
                "count": np.random.randint(0, 4),
                "types": np.random.choice(["amulet", "ring", "bracelet", "crown"], size=np.random.randint(0, 3), replace=False).tolist()
            }
        }
    
    def _generate_creature_magic_effects(self, magic_level: float) -> Dict[str, Any]:
        """Generate magical visual effects for creatures"""
        if magic_level < 0.3:
            return {"enabled": False}
        
        return {
            "enabled": True,
            "aura": {
                "color": (
                    int(138 * magic_level),
                    int(43 * magic_level),
                    int(226 * magic_level)
                ),
                "intensity": magic_level,
                "radius": 1.0 + magic_level * 2.0,
                "pulse_rate": np.random.uniform(0.5, 1.5)
            },
            "particles": {
                "enabled": magic_level > 0.5,
                "count": int(50 * magic_level),
                "pattern": "orbit" if magic_level > 0.7 else "float",
                "color": (
                    np.random.randint(100, 255),
                    np.random.randint(100, 255),
                    np.random.randint(150, 255)
                )
            },
            "trails": {
                "enabled": magic_level > 0.6,
                "length": 0.5 + magic_level,
                "fade_time": 1.0
            }
        }
    
    def _generate_movement_pattern(self) -> Dict[str, Any]:
        """Generate mathematical movement pattern"""
        patterns = ["circular", "spiral", "zigzag", "wave", "random_walk", "levy_flight"]
        return {
            "type": patterns[np.random.randint(len(patterns))],
            "amplitude": np.random.uniform(1, 5),
            "frequency": np.random.uniform(0.1, 2.0),
            "phase": np.random.uniform(0, 2 * np.pi)
        }
    
    def _generate_structures(self) -> List[Dict[str, Any]]:
        """Generate fractal-based structures"""
        structures = []
        num_structures = max(5, self.config.world_size // 80)
        
        structure_types = [
            {"name": "Fractal Tower", "iterations": 6, "style": "recursive"},
            {"name": "Sacred Geometry Temple", "iterations": 8, "style": "mandala"},
            {"name": "Crystal Spire", "iterations": 7, "style": "crystalline"},
            {"name": "Ancient Observatory", "iterations": 5, "style": "spiral"},
            {"name": "Mystic Gateway", "iterations": 4, "style": "portal"},
        ]
        
        for _ in range(num_structures):
            x = np.random.randint(20, self.config.world_size - 20)
            y = np.random.randint(20, self.config.world_size - 20)
            
            # Prefer plains or magical groves
            if self.biomes[y, x] not in [BiomeType.PLAINS.value, BiomeType.MAGICAL_GROVE.value]:
                continue
            
            structure_type = structure_types[np.random.randint(len(structure_types))]
            
            structure = {
                "type": structure_type["name"],
                "position": (x, y, self.terrain[y, x] * 50),
                "fractal_iterations": structure_type["iterations"],
                "style": structure_type["style"],
                "height": np.random.uniform(15, 40),
                "base_size": np.random.uniform(8, 20),
                "complexity": np.random.uniform(0.5, 1.0),
                "magic_runes": np.random.randint(3, 12),
                "glow_intensity": np.random.uniform(0.6, 1.0),
                "glow_color": (
                    np.random.randint(150, 255),
                    np.random.randint(100, 255),
                    np.random.randint(200, 255)
                ),
                "geometric_pattern": self._generate_structure_pattern(structure_type["style"])
            }
            structures.append(structure)
        
        return structures
    
    def _generate_structure_pattern(self, style: str) -> List[Dict[str, Any]]:
        """Generate geometric pattern for structure"""
        patterns = []
        
        if style == "recursive":
            # Sierpinski triangle-like pattern
            for i in range(3):
                patterns.append({
                    "shape": "triangle",
                    "scale": 0.5 ** i,
                    "rotation": i * 120
                })
        elif style == "mandala":
            # Radial symmetry
            for i in range(8):
                patterns.append({
                    "shape": "petal",
                    "scale": 1.0,
                    "rotation": i * 45
                })
        elif style == "crystalline":
            # Hexagonal patterns
            for i in range(6):
                patterns.append({
                    "shape": "hexagon",
                    "scale": 0.8,
                    "rotation": i * 60
                })
        elif style == "spiral":
            # Fibonacci spiral
            for i in range(5):
                patterns.append({
                    "shape": "arc",
                    "scale": 1.618 ** i,
                    "rotation": i * 137.5  # Golden angle
                })
        else:  # portal
            patterns.append({
                "shape": "circle",
                "scale": 1.0,
                "rotation": 0
            })
        
        return patterns
    
    def _generate_villages(self) -> List[Dict[str, Any]]:
        """Generate villages and settlements"""
        villages = []
        num_villages = max(3, self.config.world_size // 120)
        
        for _ in range(num_villages):
            x = np.random.randint(30, self.config.world_size - 30)
            y = np.random.randint(30, self.config.world_size - 30)
            
            # Prefer plains, forest edges
            biome = self.biomes[y, x]
            if biome not in [BiomeType.PLAINS.value, BiomeType.FOREST.value]:
                continue
            
            # Skip if too close to water
            if self.terrain[y, x] < self.config.water_level + 0.05:
                continue
            
            village_size = np.random.choice(["small", "medium", "large"], p=[0.5, 0.3, 0.2])
            num_buildings = {"small": np.random.randint(3, 8), 
                           "medium": np.random.randint(8, 15), 
                           "large": np.random.randint(15, 25)}[village_size]
            
            buildings = []
            for i in range(num_buildings):
                angle = 2 * np.pi * i / num_buildings + np.random.uniform(-0.3, 0.3)
                radius = np.random.uniform(5, 15)
                bx = x + radius * np.cos(angle)
                by = y + radius * np.sin(angle)
                
                building = {
                    "position": (bx, by, self.terrain[min(int(by), self.config.world_size-1), 
                                                      min(int(bx), self.config.world_size-1)] * 50),
                    "type": np.random.choice(["house", "shop", "inn", "temple", "workshop"]),
                    "width": np.random.uniform(4, 8),
                    "length": np.random.uniform(4, 8),
                    "height": np.random.uniform(3, 6),
                    "roof_type": np.random.choice(["peaked", "flat", "domed"]),
                    "material": np.random.choice(["wood", "stone", "mixed"]),
                    "has_chimney": np.random.random() > 0.5,
                    "windows": np.random.randint(2, 6),
                    "door_position": np.random.choice(["front", "side"])
                }
                buildings.append(building)
            
            village = {
                "name": f"Village_{len(villages) + 1}",
                "position": (x, y, self.terrain[y, x] * 50),
                "size": village_size,
                "buildings": buildings,
                "population": num_buildings * np.random.randint(2, 5),
                "biome": biome,
                "features": {
                    "market": village_size in ["medium", "large"],
                    "walls": village_size == "large",
                    "farms": np.random.randint(1, 4),
                    "well": True,
                    "paths": True
                },
                "npcs": self._generate_village_npcs(num_buildings * 2)
            }
            villages.append(village)
        
        return villages
    
    def _generate_village_npcs(self, count: int) -> List[Dict[str, Any]]:
        """Generate NPCs for a village"""
        npcs = []
        roles = ["merchant", "guard", "farmer", "craftsman", "innkeeper", "priest", "elder", "child"]
        
        for i in range(count):
            npc = {
                "id": f"npc_{i}",
                "role": roles[np.random.randint(len(roles))],
                "name": f"Villager_{i}",
                "level": np.random.randint(1, 10),
                "friendly": np.random.random() > 0.2,
                "dialogue_available": True,
                "can_trade": np.random.random() > 0.5,
                "has_quest": np.random.random() > 0.7,
                "appearance": {
                    "clothing_style": np.random.choice(["peasant", "merchant", "noble"]),
                    "age": np.random.choice(["young", "adult", "elderly"]),
                    "equipment": np.random.choice(["none", "tools", "weapons"]) if np.random.random() > 0.5 else "none"
                }
            }
            npcs.append(npc)
        
        return npcs
    
    def _generate_caves(self) -> List[Dict[str, Any]]:
        """Generate cave systems and underground areas"""
        caves = []
        num_caves = max(3, self.config.world_size // 100)
        
        for _ in range(num_caves):
            x = np.random.randint(20, self.config.world_size - 20)
            y = np.random.randint(20, self.config.world_size - 20)
            
            # Prefer mountains and hills
            if self.terrain[y, x] < 0.5:
                continue
            
            # Generate cave network using cellular automata
            cave_size = np.random.randint(15, 40)
            depth = np.random.uniform(10, 50)
            
            cave = {
                "entrance_position": (x, y, self.terrain[y, x] * 50),
                "size": cave_size,
                "depth": depth,
                "type": np.random.choice(["natural", "mines", "ancient_ruins"]),
                "chambers": self._generate_cave_chambers(cave_size),
                "resources": {
                    "minerals": np.random.randint(5, 20),
                    "crystals": np.random.randint(0, 10) if np.random.random() > 0.5 else 0,
                    "rare_ores": np.random.randint(0, 5) if np.random.random() > 0.7 else 0
                },
                "creatures": {
                    "count": np.random.randint(3, 10),
                    "types": np.random.choice(["bats", "spiders", "elementals", "undead"], 
                                             size=np.random.randint(1, 3), replace=False).tolist()
                },
                "features": {
                    "stalactites": True,
                    "underground_water": np.random.random() > 0.6,
                    "glowing_fungi": np.random.random() > 0.5,
                    "ancient_carvings": np.random.random() > 0.7
                },
                "lighting": {
                    "ambient": 0.1,
                    "has_torches": np.random.random() > 0.5,
                    "bioluminescent": np.random.random() > 0.6
                }
            }
            caves.append(cave)
        
        return caves
    
    def _generate_cave_chambers(self, cave_size: int) -> List[Dict[str, Any]]:
        """Generate interconnected cave chambers"""
        num_chambers = max(3, cave_size // 5)
        chambers = []
        
        for i in range(num_chambers):
            chamber = {
                "id": i,
                "size": np.random.uniform(3, 10),
                "height": np.random.uniform(2, 8),
                "connected_to": [j for j in range(num_chambers) if j != i and np.random.random() > 0.7],
                "has_treasure": np.random.random() > 0.8,
                "danger_level": np.random.randint(1, 5)
            }
            chambers.append(chamber)
        
        return chambers
    
    def _generate_weather_system(self) -> Dict[str, Any]:
        """Generate dynamic weather system"""
        return {
            "enabled": True,
            "current_weather": np.random.choice(["clear", "cloudy", "rain", "storm", "fog", "snow"]),
            "temperature": np.random.uniform(-10, 35),  # Celsius
            "wind": {
                "speed": np.random.uniform(0, 25),  # km/h
                "direction": np.random.uniform(0, 360),  # degrees
                "gusts": np.random.random() > 0.7
            },
            "precipitation": {
                "type": None,
                "intensity": 0.0,
                "chance": 0.3
            },
            "day_night_cycle": {
                "enabled": True,
                "current_time": np.random.uniform(0, 24),  # 0-24 hours
                "day_length": 12.0,
                "transition_duration": 1.0,
                "sun_angle": 0.0
            },
            "seasonal": {
                "current_season": np.random.choice(["spring", "summer", "autumn", "winter"]),
                "progress": np.random.uniform(0, 1),
                "effects": {
                    "temperature_modifier": 0.0,
                    "vegetation_state": 1.0,
                    "snow_coverage": 0.0
                }
            },
            "dynamic_effects": {
                "lightning": {
                    "enabled": False,
                    "frequency": 0.0,
                    "next_strike": 0.0
                },
                "rainbow": {
                    "visible": False,
                    "after_rain": True
                },
                "fog_density": np.random.uniform(0, 0.5)
            }
        }
    
    def _setup_lighting(self) -> Dict[str, Any]:
        """Setup cinematic lighting system"""
        return {
            "quality": self.config.lighting_quality,
            "ambient": {
                "color": (135, 206, 235),  # Sky blue
                "intensity": 0.3
            },
            "directional": {
                "type": "sun",
                "position": (0.5, 0.8, 0.3),
                "color": (255, 250, 205),  # Warm sunlight
                "intensity": 0.8,
                "cast_shadows": True,
                "shadow_quality": "high"
            },
            "magical_lights": [
                {
                    "type": "point",
                    "intensity": light_intensity,
                    "color": (
                        np.random.randint(150, 255),
                        np.random.randint(100, 255),
                        np.random.randint(200, 255)
                    ),
                    "radius": np.random.uniform(10, 30),
                    "flicker": True,
                    "flicker_speed": np.random.uniform(0.5, 2.0)
                }
                for light_intensity in np.random.uniform(0.5, 1.0, 20)
            ],
            "volumetric_fog": {
                "enabled": True,
                "density": 0.02,
                "color": (200, 200, 220)
            },
            "god_rays": {
                "enabled": True,
                "intensity": 0.4
            }
        }
    
    def _generate_sky(self) -> Dict[str, Any]:
        """Generate dynamic sky system"""
        return {
            "type": "dynamic",
            "time_of_day": "dawn",
            "cloud_coverage": np.random.uniform(0.2, 0.7),
            "cloud_pattern": "fractal_noise",
            "cloud_layers": [
                {
                    "altitude": altitude,
                    "speed": np.random.uniform(0.5, 2.0),
                    "opacity": np.random.uniform(0.3, 0.8),
                    "fractal_scale": np.random.uniform(50, 200)
                }
                for altitude in [1000, 2000, 3500]
            ],
            "celestial_bodies": [
                {
                    "type": "sun",
                    "position": (0.5, 0.3),
                    "size": 1.0,
                    "intensity": 1.0,
                    "color": (255, 250, 205)
                },
                {
                    "type": "moon",
                    "position": (-0.3, 0.8),
                    "size": 0.5,
                    "intensity": 0.3,
                    "color": (220, 220, 255),
                    "phase": np.random.random()  # 0-1
                }
            ],
            "stars": {
                "visible": True,
                "count": 1000,
                "twinkle": True,
                "constellations": True
            },
            "aurora": {
                "enabled": np.random.random() < 0.3,
                "colors": [(0, 255, 127), (138, 43, 226), (0, 191, 255)],
                "wave_pattern": "sinusoidal",
                "intensity": np.random.uniform(0.4, 0.8)
            },
            "atmospheric_scattering": True,
            "color_grading": {
                "temperature": np.random.uniform(5000, 7000),  # Kelvin
                "tint": np.random.uniform(-0.1, 0.1),
                "saturation": np.random.uniform(0.9, 1.2)
            }
        }
    
    def get_world_data(self) -> Dict[str, Any]:
        """Get all world data as a dictionary"""
        return {
            "config": asdict(self.config),
            "terrain_stats": {
                "size": self.config.world_size,
                "min_elevation": float(self.terrain.min()),
                "max_elevation": float(self.terrain.max()),
                "avg_elevation": float(self.terrain.mean())
            },
            "biome_distribution": self._get_biome_distribution(),
            "forests": self.forests,
            "rivers": self.rivers,
            "villages": self.villages,
            "caves": self.caves,
            "creatures": self.creatures,
            "structures": self.structures,
            "lighting": self.lighting,
            "sky": self.sky,
            "weather": self.weather,
            "features": {
                "fractal_terrain": True,
                "procedural_forests": True,
                "algorithmic_rivers": True,
                "geometric_creatures": True,
                "fractal_structures": True,
                "cinematic_lighting": True,
                "dynamic_sky": True,
                "magical_effects": True,
                "animations_enabled": self.config.enable_animations,
                "villages_enabled": True,
                "caves_enabled": True,
                "weather_system": True,
                "interactive_terrain": True,
                "realistic_textures": True,
                "facial_animations": True,
                "equipment_system": True
            }
        }
    
    def _get_biome_distribution(self) -> Dict[str, int]:
        """Get count of each biome type"""
        unique, counts = np.unique(self.biomes, return_counts=True)
        return dict(zip(unique, [int(c) for c in counts]))
    
    def save_world(self, filename: str = "fractal_world.json"):
        """Save world data to JSON file"""
        world_data = self.get_world_data()
        
        # Convert numpy arrays to lists for JSON serialization
        if self.terrain is not None:
            world_data["terrain_sample"] = self.terrain[::32, ::32].tolist()
        
        with open(filename, 'w') as f:
            json.dump(world_data, f, indent=2)
        
        print(f"ğŸ’¾ World saved to {filename}")
    
    def print_world_summary(self):
        """Print a summary of the generated world"""
        print("\n" + "="*60)
        print("ğŸŒŸ FRACTAL FANTASY WORLD SUMMARY ğŸŒŸ")
        print("="*60)
        print(f"\nğŸ“ World Size: {self.config.world_size}x{self.config.world_size}")
        print(f"ğŸ² Seed: {self.config.seed}")
        print(f"\nğŸŒ² Forests: {len(self.forests)} procedural forest patches")
        print(f"ğŸŒŠ Rivers: {len(self.rivers)} algorithmic rivers")
        print(f"ğŸ˜ï¸  Villages: {len(self.villages)} settlements")
        print(f"â›°ï¸  Caves: {len(self.caves)} cave systems")
        print(f"ğŸ‰ Creatures: {len(self.creatures)} geometric creatures")
        print(f"ğŸ° Structures: {len(self.structures)} fractal structures")
        
        print(f"\nğŸ—ºï¸  Biome Distribution:")
        biome_dist = self._get_biome_distribution()
        for biome, count in biome_dist.items():
            percentage = (count / (self.config.world_size ** 2)) * 100
            print(f"   {biome}: {percentage:.1f}%")
        
        print(f"\nğŸ’¡ Lighting: {self.config.lighting_quality} quality")
        print(f"   Magical lights: {len(self.lighting['magical_lights'])}")
        print(f"   Volumetric fog: {'Enabled' if self.lighting['volumetric_fog']['enabled'] else 'Disabled'}")
        print(f"   God rays: {'Enabled' if self.lighting['god_rays']['enabled'] else 'Disabled'}")
        
        print(f"\nğŸŒŒ Sky: Dynamic with {self.sky['cloud_coverage']:.1f} cloud coverage")
        print(f"   Aurora: {'Visible' if self.sky['aurora']['enabled'] else 'Not visible'}")
        print(f"   Stars: {self.sky['stars']['count']} visible")
        
        print(f"\nğŸŒ¦ï¸  Weather: {self.weather['current_weather']}")
        print(f"   Temperature: {self.weather['temperature']:.1f}Â°C")
        print(f"   Wind: {self.weather['wind']['speed']:.1f} km/h")
        print(f"   Time: {self.weather['day_night_cycle']['current_time']:.1f}h")
        
        print(f"\nâœ¨ Features:")
        print(f"   âœ“ Fractal terrain generation")
        print(f"   âœ“ Procedural forests (L-systems)")
        print(f"   âœ“ Algorithmic river flow")
        print(f"   âœ“ Villages with NPCs")
        print(f"   âœ“ Cave systems")
        print(f"   âœ“ Geometric creature patterns")
        print(f"   âœ“ Realistic creature textures & animations")
        print(f"   âœ“ Humanoid NPCs with equipment")
        print(f"   âœ“ Fractal architecture")
        print(f"   âœ“ Cinematic lighting")
        print(f"   âœ“ Glowing magical effects")
        print(f"   âœ“ Dynamic sky rendering")
        print(f"   âœ“ Weather system with day/night cycle")
        print(f"   âœ“ Realistic textures")
        print(f"   âœ“ Animated movements")
        print("="*60 + "\n")


def main():
    """Main function to generate and display the fractal fantasy world"""
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘         FRACTAL FANTASY WORLD GENERATOR                   â•‘
    â•‘  Epic, Immersive, Logic-Driven RPG Environment            â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    # Create world with custom configuration
    config = WorldConfig(
        seed=42,
        world_size=256,
        fractal_iterations=8,
        terrain_roughness=0.6,
        water_level=0.3,
        tree_density=0.5,
        creature_density=0.15,
        magic_intensity=0.8,
        lighting_quality="cinematic",
        enable_animations=True
    )
    
    world = FractalWorld(config)
    world.generate_world()
    world.print_world_summary()
    world.save_world("fractal_world.json")
    
    print("\nğŸ® Ready for your logic-driven RPG adventure!")


if __name__ == "__main__":
    main()
