"""
Fractal Fantasy World - Main Game Engine
=========================================
Epic, immersive fantasy world where nature, creatures, and structures 
are generated by fractals, logic, and math patterns.
"""

import numpy as np
import json
from typing import Dict, List, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum


class BiomeType(Enum):
    """Biome types for the fantasy world"""
    FOREST = "forest"
    MOUNTAINS = "mountains"
    PLAINS = "plains"
    DESERT = "desert"
    SWAMP = "swamp"
    TUNDRA = "tundra"
    MAGICAL_GROVE = "magical_grove"


@dataclass
class WorldConfig:
    """Configuration for world generation"""
    seed: int = 42
    world_size: int = 512
    fractal_iterations: int = 8
    terrain_roughness: float = 0.6
    water_level: float = 0.3
    tree_density: float = 0.4
    creature_density: float = 0.1
    magic_intensity: float = 0.7
    lighting_quality: str = "cinematic"
    enable_animations: bool = True


class FractalWorld:
    """Main class for the fractal-based fantasy world"""
    
    def __init__(self, config: WorldConfig = None):
        self.config = config or WorldConfig()
        np.random.seed(self.config.seed)
        self.terrain = None
        self.biomes = None
        self.forests = []
        self.rivers = []
        self.creatures = []
        self.structures = []
        self.lighting = None
        self.sky = None
        
    def generate_world(self) -> Dict[str, Any]:
        """Generate the complete fantasy world"""
        print("ğŸŒ Generating Fractal Fantasy World...")
        
        # Generate terrain using fractal algorithms
        self.terrain = self._generate_terrain()
        print("  âœ“ Terrain generated with fractal patterns")
        
        # Generate biomes based on terrain
        self.biomes = self._generate_biomes()
        print("  âœ“ Biomes generated using mathematical rules")
        
        # Generate procedural forests
        self.forests = self._generate_forests()
        print(f"  âœ“ {len(self.forests)} procedural forests generated")
        
        # Generate rivers with flow algorithms
        self.rivers = self._generate_rivers()
        print(f"  âœ“ {len(self.rivers)} algorithmic rivers generated")
        
        # Generate creatures with geometric patterns
        self.creatures = self._generate_creatures()
        print(f"  âœ“ {len(self.creatures)} geometric creatures spawned")
        
        # Generate fractal structures
        self.structures = self._generate_structures()
        print(f"  âœ“ {len(self.structures)} fractal structures created")
        
        # Setup lighting system
        self.lighting = self._setup_lighting()
        print("  âœ“ Cinematic lighting configured")
        
        # Generate dynamic sky
        self.sky = self._generate_sky()
        print("  âœ“ Dynamic sky system initialized")
        
        print("âœ¨ World generation complete!")
        
        return self.get_world_data()
    
    def _generate_terrain(self) -> np.ndarray:
        """Generate terrain using multi-octave fractal noise"""
        size = self.config.world_size
        terrain = np.zeros((size, size))
        
        # Generate multiple octaves of noise for fractal terrain
        octaves = min(self.config.fractal_iterations, 8)
        roughness = self.config.terrain_roughness
        
        for octave in range(octaves):
            freq = 2 ** octave
            amp = roughness ** octave
            
            for y in range(size):
                for x in range(size):
                    # Generate fractal noise using sine/cosine combinations
                    nx = x / size * freq
                    ny = y / size * freq
                    
                    # Combine multiple noise sources
                    noise = (np.sin(nx * 3.14159 + np.random.random() * 0.1) * 
                            np.cos(ny * 3.14159 + np.random.random() * 0.1))
                    noise += (np.sin(nx * 1.5 + 2.5) * np.cos(ny * 1.5 + 3.7)) * 0.5
                    
                    terrain[y, x] += noise * amp
        
        # Apply additional fractal detail using diamond-square-like perturbations
        for _ in range(3):
            for y in range(1, size - 1):
                for x in range(1, size - 1):
                    # Average neighbors with some randomness
                    avg = (terrain[y-1, x] + terrain[y+1, x] + 
                          terrain[y, x-1] + terrain[y, x+1]) / 4
                    terrain[y, x] = terrain[y, x] * 0.7 + avg * 0.3 + \
                                   np.random.uniform(-roughness, roughness) * 0.1
        
        # Normalize terrain to [0, 1]
        terrain = (terrain - terrain.min()) / (terrain.max() - terrain.min())
        return terrain
    
    def _generate_biomes(self) -> np.ndarray:
        """Generate biomes based on terrain height and moisture"""
        size = self.config.world_size
        biomes = np.zeros((size, size), dtype=object)
        
        # Generate moisture map using Perlin-like noise
        moisture = self._generate_noise_map(size, scale=50)
        
        for y in range(size):
            for x in range(size):
                height = self.terrain[y, x]
                m = moisture[y, x]
                
                # Determine biome based on height and moisture
                if height < self.config.water_level:
                    biomes[y, x] = "water"
                elif height > 0.8:
                    biomes[y, x] = BiomeType.MOUNTAINS.value
                elif height > 0.6 and m < 0.3:
                    biomes[y, x] = BiomeType.DESERT.value
                elif m > 0.7:
                    if np.random.random() < self.config.magic_intensity * 0.2:
                        biomes[y, x] = BiomeType.MAGICAL_GROVE.value
                    else:
                        biomes[y, x] = BiomeType.FOREST.value
                elif m > 0.5:
                    biomes[y, x] = BiomeType.SWAMP.value if height < 0.4 else BiomeType.FOREST.value
                elif height < 0.35 and m < 0.4:
                    biomes[y, x] = BiomeType.TUNDRA.value
                else:
                    biomes[y, x] = BiomeType.PLAINS.value
        
        return biomes
    
    def _generate_noise_map(self, size: int, scale: float) -> np.ndarray:
        """Generate Perlin-like noise map"""
        noise = np.zeros((size, size))
        
        for octave in range(4):
            freq = 2 ** octave / scale
            amp = 0.5 ** octave
            
            for y in range(size):
                for x in range(size):
                    noise[y, x] += np.sin(x * freq + np.random.random()) * \
                                   np.cos(y * freq + np.random.random()) * amp
        
        noise = (noise - noise.min()) / (noise.max() - noise.min())
        return noise
    
    def _generate_forests(self) -> List[Dict[str, Any]]:
        """Generate procedural forests using L-systems"""
        forests = []
        
        for y in range(0, self.config.world_size, 20):
            for x in range(0, self.config.world_size, 20):
                if self.biomes[y, x] in [BiomeType.FOREST.value, BiomeType.MAGICAL_GROVE.value]:
                    if np.random.random() < self.config.tree_density:
                        forest = self._create_forest_patch(x, y)
                        forests.append(forest)
        
        return forests
    
    def _create_forest_patch(self, x: int, y: int) -> Dict[str, Any]:
        """Create a forest patch using L-system tree generation"""
        is_magical = self.biomes[y, x] == BiomeType.MAGICAL_GROVE.value
        
        # L-system parameters for tree generation
        axiom = "F"
        rules = {"F": "FF+[+F-F-F]-[-F+F+F]"}
        iterations = 4
        angle = 25
        
        # Generate L-system string
        current = axiom
        for _ in range(iterations):
            next_str = ""
            for char in current:
                next_str += rules.get(char, char)
            current = next_str
        
        trees = []
        num_trees = np.random.randint(5, 15)
        
        for _ in range(num_trees):
            tree_x = x + np.random.randint(-10, 10)
            tree_y = y + np.random.randint(-10, 10)
            height = np.random.uniform(3, 8) if not is_magical else np.random.uniform(5, 12)
            
            tree = {
                "position": (tree_x, tree_y, self.terrain[min(y, self.config.world_size-1), 
                                                         min(x, self.config.world_size-1)] * 50),
                "l_system": current[:50],  # Truncate for storage
                "height": height,
                "angle": angle,
                "is_magical": is_magical,
                "glow_intensity": np.random.uniform(0.5, 1.0) if is_magical else 0,
                "foliage_density": np.random.uniform(0.6, 1.0)
            }
            trees.append(tree)
        
        return {
            "center": (x, y),
            "trees": trees,
            "biome": self.biomes[y, x]
        }
    
    def _generate_rivers(self) -> List[Dict[str, Any]]:
        """Generate rivers using flow algorithms"""
        rivers = []
        num_rivers = max(3, self.config.world_size // 100)
        
        for _ in range(num_rivers):
            # Start from high elevation
            start_points = np.where(self.terrain > 0.7)
            if len(start_points[0]) == 0:
                continue
                
            idx = np.random.randint(len(start_points[0]))
            start_y, start_x = start_points[0][idx], start_points[1][idx]
            
            # Flow downhill using gradient descent
            path = [(start_x, start_y, self.terrain[start_y, start_x])]
            current_x, current_y = start_x, start_y
            
            for _ in range(200):
                # Find lowest neighbor
                lowest_h = self.terrain[current_y, current_x]
                next_x, next_y = current_x, current_y
                
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        ny, nx = current_y + dy, current_x + dx
                        if 0 <= ny < self.config.world_size and 0 <= nx < self.config.world_size:
                            if self.terrain[ny, nx] < lowest_h:
                                lowest_h = self.terrain[ny, nx]
                                next_x, next_y = nx, ny
                
                if (next_x, next_y) == (current_x, current_y):
                    break  # Reached local minimum
                
                current_x, current_y = next_x, next_y
                path.append((current_x, current_y, self.terrain[current_y, current_x]))
                
                if self.terrain[current_y, current_x] < self.config.water_level:
                    break  # Reached water
            
            if len(path) > 10:
                rivers.append({
                    "path": path,
                    "width": np.random.uniform(2, 8),
                    "flow_speed": np.random.uniform(0.5, 2.0),
                    "has_magic": np.random.random() < self.config.magic_intensity * 0.3,
                    "glow_color": (
                        np.random.randint(100, 255),
                        np.random.randint(150, 255),
                        np.random.randint(200, 255)
                    ) if np.random.random() < 0.3 else None
                })
        
        return rivers
    
    def _generate_creatures(self) -> List[Dict[str, Any]]:
        """Generate creatures with geometric patterns"""
        creatures = []
        num_creatures = int(self.config.world_size * self.config.world_size * self.config.creature_density / 1000)
        
        creature_types = [
            {"name": "Fractal Dragon", "pattern": "mandelbrot", "size": "large", "magic": 0.9},
            {"name": "Geometric Wolf", "pattern": "hexagonal", "size": "medium", "magic": 0.3},
            {"name": "Spiral Serpent", "pattern": "fibonacci", "size": "medium", "magic": 0.6},
            {"name": "Crystal Spider", "pattern": "octahedral", "size": "small", "magic": 0.4},
            {"name": "Pattern Bird", "pattern": "recursive", "size": "small", "magic": 0.5},
            {"name": "Golden Bear", "pattern": "golden_ratio", "size": "large", "magic": 0.2},
        ]
        
        for _ in range(num_creatures):
            x = np.random.randint(0, self.config.world_size)
            y = np.random.randint(0, self.config.world_size)
            
            # Skip water areas
            if self.terrain[y, x] < self.config.water_level:
                continue
            
            creature_type = creature_types[np.random.randint(len(creature_types))]
            
            creature = {
                "type": creature_type["name"],
                "position": (x, y, self.terrain[y, x] * 50),
                "pattern": creature_type["pattern"],
                "size": creature_type["size"],
                "geometric_complexity": np.random.randint(4, 12),
                "color_palette": self._generate_geometric_colors(creature_type["pattern"]),
                "magic_level": creature_type["magic"] * self.config.magic_intensity,
                "glow_intensity": creature_type["magic"] * np.random.uniform(0.5, 1.0),
                "animation_speed": np.random.uniform(0.5, 1.5),
                "movement_pattern": self._generate_movement_pattern(),
                "biome": self.biomes[y, x]
            }
            creatures.append(creature)
        
        return creatures
    
    def _generate_geometric_colors(self, pattern: str) -> List[Tuple[int, int, int]]:
        """Generate color palette based on geometric pattern"""
        palettes = {
            "mandelbrot": [(75, 0, 130), (138, 43, 226), (186, 85, 211)],
            "hexagonal": [(255, 215, 0), (255, 165, 0), (255, 140, 0)],
            "fibonacci": [(34, 139, 34), (50, 205, 50), (144, 238, 144)],
            "octahedral": [(135, 206, 235), (176, 224, 230), (240, 248, 255)],
            "recursive": [(220, 20, 60), (255, 99, 71), (255, 160, 122)],
            "golden_ratio": [(184, 134, 11), (218, 165, 32), (238, 232, 170)]
        }
        return palettes.get(pattern, [(128, 128, 128)])
    
    def _generate_movement_pattern(self) -> Dict[str, Any]:
        """Generate mathematical movement pattern"""
        patterns = ["circular", "spiral", "zigzag", "wave", "random_walk", "levy_flight"]
        return {
            "type": patterns[np.random.randint(len(patterns))],
            "amplitude": np.random.uniform(1, 5),
            "frequency": np.random.uniform(0.1, 2.0),
            "phase": np.random.uniform(0, 2 * np.pi)
        }
    
    def _generate_structures(self) -> List[Dict[str, Any]]:
        """Generate fractal-based structures"""
        structures = []
        num_structures = max(5, self.config.world_size // 80)
        
        structure_types = [
            {"name": "Fractal Tower", "iterations": 6, "style": "recursive"},
            {"name": "Sacred Geometry Temple", "iterations": 8, "style": "mandala"},
            {"name": "Crystal Spire", "iterations": 7, "style": "crystalline"},
            {"name": "Ancient Observatory", "iterations": 5, "style": "spiral"},
            {"name": "Mystic Gateway", "iterations": 4, "style": "portal"},
        ]
        
        for _ in range(num_structures):
            x = np.random.randint(20, self.config.world_size - 20)
            y = np.random.randint(20, self.config.world_size - 20)
            
            # Prefer plains or magical groves
            if self.biomes[y, x] not in [BiomeType.PLAINS.value, BiomeType.MAGICAL_GROVE.value]:
                continue
            
            structure_type = structure_types[np.random.randint(len(structure_types))]
            
            structure = {
                "type": structure_type["name"],
                "position": (x, y, self.terrain[y, x] * 50),
                "fractal_iterations": structure_type["iterations"],
                "style": structure_type["style"],
                "height": np.random.uniform(15, 40),
                "base_size": np.random.uniform(8, 20),
                "complexity": np.random.uniform(0.5, 1.0),
                "magic_runes": np.random.randint(3, 12),
                "glow_intensity": np.random.uniform(0.6, 1.0),
                "glow_color": (
                    np.random.randint(150, 255),
                    np.random.randint(100, 255),
                    np.random.randint(200, 255)
                ),
                "geometric_pattern": self._generate_structure_pattern(structure_type["style"])
            }
            structures.append(structure)
        
        return structures
    
    def _generate_structure_pattern(self, style: str) -> List[Dict[str, Any]]:
        """Generate geometric pattern for structure"""
        patterns = []
        
        if style == "recursive":
            # Sierpinski triangle-like pattern
            for i in range(3):
                patterns.append({
                    "shape": "triangle",
                    "scale": 0.5 ** i,
                    "rotation": i * 120
                })
        elif style == "mandala":
            # Radial symmetry
            for i in range(8):
                patterns.append({
                    "shape": "petal",
                    "scale": 1.0,
                    "rotation": i * 45
                })
        elif style == "crystalline":
            # Hexagonal patterns
            for i in range(6):
                patterns.append({
                    "shape": "hexagon",
                    "scale": 0.8,
                    "rotation": i * 60
                })
        elif style == "spiral":
            # Fibonacci spiral
            for i in range(5):
                patterns.append({
                    "shape": "arc",
                    "scale": 1.618 ** i,
                    "rotation": i * 137.5  # Golden angle
                })
        else:  # portal
            patterns.append({
                "shape": "circle",
                "scale": 1.0,
                "rotation": 0
            })
        
        return patterns
    
    def _setup_lighting(self) -> Dict[str, Any]:
        """Setup cinematic lighting system"""
        return {
            "quality": self.config.lighting_quality,
            "ambient": {
                "color": (135, 206, 235),  # Sky blue
                "intensity": 0.3
            },
            "directional": {
                "type": "sun",
                "position": (0.5, 0.8, 0.3),
                "color": (255, 250, 205),  # Warm sunlight
                "intensity": 0.8,
                "cast_shadows": True,
                "shadow_quality": "high"
            },
            "magical_lights": [
                {
                    "type": "point",
                    "intensity": light_intensity,
                    "color": (
                        np.random.randint(150, 255),
                        np.random.randint(100, 255),
                        np.random.randint(200, 255)
                    ),
                    "radius": np.random.uniform(10, 30),
                    "flicker": True,
                    "flicker_speed": np.random.uniform(0.5, 2.0)
                }
                for light_intensity in np.random.uniform(0.5, 1.0, 20)
            ],
            "volumetric_fog": {
                "enabled": True,
                "density": 0.02,
                "color": (200, 200, 220)
            },
            "god_rays": {
                "enabled": True,
                "intensity": 0.4
            }
        }
    
    def _generate_sky(self) -> Dict[str, Any]:
        """Generate dynamic sky system"""
        return {
            "type": "dynamic",
            "time_of_day": "dawn",
            "cloud_coverage": np.random.uniform(0.2, 0.7),
            "cloud_pattern": "fractal_noise",
            "cloud_layers": [
                {
                    "altitude": altitude,
                    "speed": np.random.uniform(0.5, 2.0),
                    "opacity": np.random.uniform(0.3, 0.8),
                    "fractal_scale": np.random.uniform(50, 200)
                }
                for altitude in [1000, 2000, 3500]
            ],
            "celestial_bodies": [
                {
                    "type": "sun",
                    "position": (0.5, 0.3),
                    "size": 1.0,
                    "intensity": 1.0,
                    "color": (255, 250, 205)
                },
                {
                    "type": "moon",
                    "position": (-0.3, 0.8),
                    "size": 0.5,
                    "intensity": 0.3,
                    "color": (220, 220, 255),
                    "phase": np.random.random()  # 0-1
                }
            ],
            "stars": {
                "visible": True,
                "count": 1000,
                "twinkle": True,
                "constellations": True
            },
            "aurora": {
                "enabled": np.random.random() < 0.3,
                "colors": [(0, 255, 127), (138, 43, 226), (0, 191, 255)],
                "wave_pattern": "sinusoidal",
                "intensity": np.random.uniform(0.4, 0.8)
            },
            "atmospheric_scattering": True,
            "color_grading": {
                "temperature": np.random.uniform(5000, 7000),  # Kelvin
                "tint": np.random.uniform(-0.1, 0.1),
                "saturation": np.random.uniform(0.9, 1.2)
            }
        }
    
    def get_world_data(self) -> Dict[str, Any]:
        """Get all world data as a dictionary"""
        return {
            "config": asdict(self.config),
            "terrain_stats": {
                "size": self.config.world_size,
                "min_elevation": float(self.terrain.min()),
                "max_elevation": float(self.terrain.max()),
                "avg_elevation": float(self.terrain.mean())
            },
            "biome_distribution": self._get_biome_distribution(),
            "forests": self.forests,
            "rivers": self.rivers,
            "creatures": self.creatures,
            "structures": self.structures,
            "lighting": self.lighting,
            "sky": self.sky,
            "features": {
                "fractal_terrain": True,
                "procedural_forests": True,
                "algorithmic_rivers": True,
                "geometric_creatures": True,
                "fractal_structures": True,
                "cinematic_lighting": True,
                "dynamic_sky": True,
                "magical_effects": True,
                "animations_enabled": self.config.enable_animations
            }
        }
    
    def _get_biome_distribution(self) -> Dict[str, int]:
        """Get count of each biome type"""
        unique, counts = np.unique(self.biomes, return_counts=True)
        return dict(zip(unique, [int(c) for c in counts]))
    
    def save_world(self, filename: str = "fractal_world.json"):
        """Save world data to JSON file"""
        world_data = self.get_world_data()
        
        # Convert numpy arrays to lists for JSON serialization
        if self.terrain is not None:
            world_data["terrain_sample"] = self.terrain[::32, ::32].tolist()
        
        with open(filename, 'w') as f:
            json.dump(world_data, f, indent=2)
        
        print(f"ğŸ’¾ World saved to {filename}")
    
    def print_world_summary(self):
        """Print a summary of the generated world"""
        print("\n" + "="*60)
        print("ğŸŒŸ FRACTAL FANTASY WORLD SUMMARY ğŸŒŸ")
        print("="*60)
        print(f"\nğŸ“ World Size: {self.config.world_size}x{self.config.world_size}")
        print(f"ğŸ² Seed: {self.config.seed}")
        print(f"\nğŸŒ² Forests: {len(self.forests)} procedural forest patches")
        print(f"ğŸŒŠ Rivers: {len(self.rivers)} algorithmic rivers")
        print(f"ğŸ‰ Creatures: {len(self.creatures)} geometric creatures")
        print(f"ğŸ° Structures: {len(self.structures)} fractal structures")
        
        print(f"\nğŸ—ºï¸  Biome Distribution:")
        biome_dist = self._get_biome_distribution()
        for biome, count in biome_dist.items():
            percentage = (count / (self.config.world_size ** 2)) * 100
            print(f"   {biome}: {percentage:.1f}%")
        
        print(f"\nğŸ’¡ Lighting: {self.config.lighting_quality} quality")
        print(f"   Magical lights: {len(self.lighting['magical_lights'])}")
        print(f"   Volumetric fog: {'Enabled' if self.lighting['volumetric_fog']['enabled'] else 'Disabled'}")
        print(f"   God rays: {'Enabled' if self.lighting['god_rays']['enabled'] else 'Disabled'}")
        
        print(f"\nğŸŒŒ Sky: Dynamic with {self.sky['cloud_coverage']:.1f} cloud coverage")
        print(f"   Aurora: {'Visible' if self.sky['aurora']['enabled'] else 'Not visible'}")
        print(f"   Stars: {self.sky['stars']['count']} visible")
        
        print(f"\nâœ¨ Features:")
        print(f"   âœ“ Fractal terrain generation")
        print(f"   âœ“ Procedural forests (L-systems)")
        print(f"   âœ“ Algorithmic river flow")
        print(f"   âœ“ Geometric creature patterns")
        print(f"   âœ“ Fractal architecture")
        print(f"   âœ“ Cinematic lighting")
        print(f"   âœ“ Glowing magical effects")
        print(f"   âœ“ Dynamic sky rendering")
        print(f"   âœ“ Realistic textures")
        print(f"   âœ“ Animated movements")
        print("="*60 + "\n")


def main():
    """Main function to generate and display the fractal fantasy world"""
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘         FRACTAL FANTASY WORLD GENERATOR                   â•‘
    â•‘  Epic, Immersive, Logic-Driven RPG Environment            â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    # Create world with custom configuration
    config = WorldConfig(
        seed=42,
        world_size=256,
        fractal_iterations=8,
        terrain_roughness=0.6,
        water_level=0.3,
        tree_density=0.5,
        creature_density=0.15,
        magic_intensity=0.8,
        lighting_quality="cinematic",
        enable_animations=True
    )
    
    world = FractalWorld(config)
    world.generate_world()
    world.print_world_summary()
    world.save_world("fractal_world.json")
    
    print("\nğŸ® Ready for your logic-driven RPG adventure!")


if __name__ == "__main__":
    main()
